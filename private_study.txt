클래스에서 오버라이딩 
: 상속 받은 부모 클래스에 있는 함수를 그냥 덮어쓰기 하는 것. 
예를 들어 over()라는 함수가 부모 클래스에 있는데, 이 기능이 마음에 들지 않는다면 그냥 똑같은 함수 다시 정의해서 작성하면 덮어쓰기가 됨
사용하다가 부모 클래스의 원래 over() 함수를 불러오고 싶다면 Parent::over() 방식으로 불러오면 됨


포인터(*)와 참조(&)

: 매개변수를 단순히 값으로만 전달했을 경우, 함수에선 그저 복사된 값을 사용하기 때문에 원본 값을 바꾸거나 하지는 못 함.
  따라서 원본에 접근해 값을 읽거나 수정하기 위해 포인터와 참조를 사용함.

포인터 -> 주소를 전달 받아 주소가 가리키는 메모리 공간에 가서(원본에 접근해서) 값을 읽거나 수정 가능.
         그러나 사실 단순한 주소 값의 복사이기 때문에 포인터가 가리키는 대상(주소) 자체를 변경할 수는 없음
         아래의 예시에서, ptr의 주소값과 num의 주소값은 다르며, 그저 ptr은 num의 주소값을 '값'으로 가지고 있는 것.
         즉, num의 값 : 3 / 주소 : 0001 /// ptr의 값 : 0001 / 주소 : 0008    이런식. 

ex)  void func(int * ptr) {*ptr *= 2; }
     int num = 3;
     func(&num);
     매개변수를 포인터로 주고 함수 호출 시 주소를 전달한다. (&a 라는 식으로 넘겨준다 = a의 주소값을 넘겨준다)



참조 -> 그러나 참조는 값과 주소값이 같아짐.

ex) void func(int & a) {a *= 2; }
        int num = 3;
        func(num);
        매개변수를 참조형 변수로 주고 함수 호출 시 값을 전달한다.


정리하면, ptr1 == &num 일 때 &ptr1 != &num 이지만, ref == num 일 때 &ref == &num임.
